/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package classifiers.svm;

import framework.AbstractMultiClassifier;
import framework.Classifier;
import framework.Fac;
import framework.ResultSet;
import framework.SampleSet;
import io.CommandExecutor;
import io.FileProcessor;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.concurrent.atomic.AtomicInteger;
import vector.Vector;

/**
 *
 * @author Istvan Sarandi (istvan.sarandi@gmail.com)
 */
public class MulticlassSVM extends AbstractMultiClassifier<Vector, Integer> implements SVM
{

    static int pref = 6;
    
    // fill this!
    static String baseDir = "";
    
    
    String trainExePath = baseDir + "svm_multiclass_learn.exe";
    String classifyExePath = baseDir + "svm_multiclass_classify.exe";
    
    String trainingFile = baseDir + "svm_training_data" + pref + ".txt";
    String testFile = baseDir + "svm_test_data" + pref + ".txt";
    String modelFile = baseDir + "svm_model" + pref + "%d.txt";
    String outputFile = baseDir + "svm_output" + pref + "%d.txt";
    
    private static AtomicInteger idCounter = new AtomicInteger(0);
    private int id;

    double c = 0.1;

    public void setC(double c)
    {
        this.c = c;
    }

    public MulticlassSVM(double c)
    {
        this.id = idCounter.getAndIncrement();
        this.c = c;
        
        trainingFile = String.format(trainingFile, id);
        testFile = String.format(testFile, id);
        modelFile = String.format(modelFile, id);
        outputFile = String.format(outputFile, id);
    }
    
    public MulticlassSVM()
    {
        this(0.1);
    }
           
    public List<ResultSet<Integer>> classifyMany(List<Vector> inputs, int limit)
    {
        // exporting the input vectors to the format accepted by external executable
        SampleSet<Vector, Integer> sampleSet = new SampleSet<Vector, Integer>(inputs, Collections.nCopies(inputs.size(), 0));
        FileProcessor.writeToFile(sampleSet.export(), testFile);
        
        // executing the external program
        String testCmd = String.format(Locale.US, "%s %s %s %s", classifyExePath, testFile, modelFile, outputFile);
        CommandExecutor.execute(testCmd);
        
        // reading and parsing the file generated by external executable
        String output = FileProcessor.readFromFile(outputFile);
        List<ResultSet<Integer>> resultSets = new ArrayList<ResultSet<Integer>>(inputs.size());
        
        for (String line : output.split(System.getProperty("line.separator")))
        {
            ResultSet<Integer> rs = new ResultSet<Integer>(limit);
            int classID = -1;
            
            for (String word: line.split(" "))
            {
                if (classID != -1) //first word is the best class, then come the "probabilities"
                    rs.push(classID, Double.parseDouble(word));
                
                ++classID;
            }
            resultSets.add(rs);
        }

        return resultSets;

    }

    public void train(SampleSet<Vector, Integer> trainingSet)
    {
        //exporting trainingset to the format of the external application
        FileProcessor.writeToFile(trainingSet.export(), trainingFile);

        //executing the external application
        String trainCmd = String.format(Locale.US, "%s -c %6.3e %s %s", trainExePath, c, trainingFile, modelFile);

        //System.out.println("training svm");
        long before = Calendar.getInstance().getTimeInMillis();
        CommandExecutor.execute(trainCmd);
        long elapsed = Calendar.getInstance().getTimeInMillis() - before;

        //System.out.println("SVM time: " + elapsed + " ms");
    }

    @Override
    public String toString()
    {
        return "MulticlassSVM{" + "c=" + c + '}';
    }

   
    public static class Factory implements Fac<Classifier<Vector,Integer>>
    {
        double c;

        public Factory(double c)
        {
            this.c = c;
        }
        
        public Classifier<Vector, Integer> createNew()
        {
            MulticlassSVM svm =  new MulticlassSVM();
            svm.setC(c);
            return svm;
        }
        
    }
}
